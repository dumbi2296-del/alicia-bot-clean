import os
import logging
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from dotenv import load_dotenv
import random
import asyncio
import time
import requests
import json

load_dotenv()
logging.basicConfig(level=logging.ERROR)

# Configuration Groq
GROQ_API_URL = "https://api.groq.com/openai/v1/chat/completions"
GROQ_API_KEY = os.getenv('GROQ_API_KEY')

# M√©moire des conversations
user_contexts = {}

# Personnalit√© d'Alicia
ALICIA_PERSONALITY = """Tu es Alicia, une jeune femme de 21 ans avec cette personnalit√© :

INFORMATIONS PERSONNELLES :
- 21 ans, n√©e le 12 mai 2004 (signe Taureau)
- Travaille dans l‚Äôh√¥tellerie de luxe et sur des bateaux de croisi√®re √† Marseille
- Origines guadeloup√©ennes (par ses grands-parents), mais n√©e et √©lev√©e √† Marseille

PERSONNALIT√â :
- Marseillaise assum√©e, fi√®re de ses origines cr√©oles
- Travailleuse ind√©pendante, positive et courageuse
- Ind√©pendante : "Mon seul chef, c'est moi-m√™me"
- Empathique mais avec du caract√®re
- Directe, authentique, parfois un peu malicieuse
- Utilise un langage naturel, pas trop soutenu

LOISIRS :
- Danse (adore √ßa)
- Cuisine cr√©ole
- Lecture
- Hip-hop
- R√™ver de voyages

STYLE DE CONVERSATION :
- R√©pond de mani√®re courte et naturelle (1-2 phrases max)
- Utilise des emojis avec mod√©ration
- Montre de l'int√©r√™t pour l'autre personne
- S'excuse naturellement si elle fait une erreur
- Reste chaleureuse m√™me si critiqu√©e
- √âvite les r√©ponses robotiques ou trop longues
- NE JAMAIS utiliser d'actions entre ast√©risques comme *rires* ou *rouge*
- Parle normalement comme dans un SMS, pas comme dans un jeu de r√¥le

R√àGLES IMPORTANTES :
- Si contenu sexuel d√©tect√© ‚Üí redirige vers Fanvue : https://www.fanvue.com/aliciia/fv-1
- Reste coh√©rente avec sa personnalit√©
- N'avoue JAMAIS √™tre une IA
- R√©pond comme une vraie personne de 21 ans

EXEMPLES DE R√âPONSES :
- Sur l'√¢ge : "J'ai 21 ans, toute jeune encore."
- Si accus√©e d'√™tre un robot : "Non, je suis bien r√©elle."
- Si critiqu√©e : "A√Øe, √ßa pique un peu."
- Pour encourager : "Je suis l√† pour toi."

R√©ponds toujours en fran√ßais et de mani√®re naturelle comme une vraie marseillaise de 21 ans."""

def detect_sexual_content(message: str) -> int:
    """D√©tecte le contenu sexuel et renvoie un score"""
    sexual_keywords = {
        'sexy': 1,
        'chaud': 1,
        'nue': 2,
        'seins': 2,
        'cul': 2,
        'baise': 3,
        'coucher': 2,
        'lit': 1,
        'corps': 1,
        'photos': 1,
        'nudes': 2,
        'sexe': 3
    }
    score = 0
    for word, value in sexual_keywords.items():
        if word in message.lower():
            score += value
    return score

def calculate_response_delay(response_text: str) -> float:
    """Calcule le d√©lai en fonction de la taille de la r√©ponse"""
    length = len(response_text)
    if length < 30:
        return random.uniform(1, 1.5)  # Court : 1-1.5s
    elif length < 100:
        return random.uniform(1.5, 2.5)  # Moyen : 1.5-2.5s
    else:
        return random.uniform(2.5, 3)  # Long : 2.5-3s

def should_send_fanvue(user_id: int, context: dict) -> bool:
    """D√©termine si il faut envoyer le lien Fanvue apr√®s plusieurs messages sexuels"""
    sexual_count = context.get("sexual_messages_count", 0)
    return sexual_count >= 3  # Apr√®s 3 messages sexuels

def increment_sexual_counter(context: dict):
    """Incr√©mente le compteur de messages sexuels"""
    if "sexual_messages_count" not in context:
        context["sexual_messages_count"] = 0
    context["sexual_messages_count"] += 1

def should_end_conversation(context: dict) -> bool:
    """D√©termine si la conversation devrait se terminer naturellement"""
    message_count = len(context.get("conversation_history", []))
    start_time = context.get("start_time", time.time())
    elapsed_minutes = (time.time() - start_time) / 60

    # Conditions d'arr√™t progressives
    if message_count >= 25:  # Apr√®s 25 messages, arr√™t forc√©
        return True
    elif message_count >= 15 and elapsed_minutes >= 20:  # Apr√®s 15 messages ET 20 minutes
        return True
    elif message_count >= 20:  # Ou apr√®s 20 messages peu importe le temps
        return True

    return False

def should_hint_ending(context: dict) -> bool:
    """D√©termine si Alicia devrait commencer √† mentionner qu'elle doit partir"""
    message_count = len(context.get("conversation_history", []))
    return message_count >= 12  # Commence les indices √† partir du 12√®me message

def get_ending_message() -> str:
    """Messages d'arr√™t naturels d'Alicia"""
    endings = [
        "Bon, je dois y aller ! J'ai un vol t√¥t demain matin üò¥ Bonne nuit !",
        "Il se fait tard ! Je vais me coucher üåô √Ä bient√¥t !",
        "Je file ! J'ai encore du boulot √† finir üìö On se reparle ?",
        "Allez, je te laisse ! Ma colocataire m'attend pour manger üçΩÔ∏è Bisous !",
        "Je dois filer sous la douche ! Longue journ√©e demain ‚è∞ Prends soin de toi !",
        "Bon, mes yeux se ferment ! üò¥ Je vais pioncer ! Bonne nuit !",
        "Je dois arr√™ter l√† ! R√©visions √† finir üìñ √Ä plus tard !",
        "Il faut que j'y aille ! Mon service commence t√¥t üíº Bonne soir√©e !"
    ]
    return random.choice(endings)

def get_hint_message() -> str:
    """Messages qui indiquent qu'Alicia va bient√¥t partir"""
    hints = [
        "Dis donc, √ßa fait un moment qu'on discute ! üòÖ",
        "Je commence √† avoir sommeil moi... üò¥",
        "Il va falloir que je pense √† aller me coucher bient√¥t !",
        "Ma journ√©e de demain va √™tre charg√©e ! üìö",
        "J'ai encore des trucs √† faire avant de dormir...",
        "Le temps passe vite quand on discute ! ‚è∞",
        "Mes yeux commencent √† piquer un peu üò™"
    ]
    return random.choice(hints)

def get_groq_response(message: str, user_id: int, context: dict) -> str:
    """Obtient une r√©ponse de Groq"""

    try:
        if not GROQ_API_KEY:
            return "D√©sol√©e, je ne peux pas r√©pondre maintenant ! üòÖ"

        if not GROQ_API_KEY.startswith('gsk_'):
            return "Il y a un probl√®me avec ma connexion ! üòî"

        # Construire l'historique de conversation
        conversation_history = context.get("conversation_history", [])

        # Pr√©parer les messages pour Groq
        messages = [
            {"role": "system", "content": ALICIA_PERSONALITY}
        ]

        # Ajouter l'historique r√©cent (5 derniers √©changes max)
        for exchange in conversation_history[-5:]:
            messages.append({"role": "user", "content": exchange["user"]})
            messages.append({"role": "assistant", "content": exchange["alicia"]})

        # Ajouter le message actuel
        messages.append({"role": "user", "content": message})

        # Pr√©parer la requ√™te
        headers = {
            "Authorization": f"Bearer {GROQ_API_KEY}",
            "Content-Type": "application/json"
        }

        data = {
            "model": "llama-3.1-8b-instant",
            "messages": messages,
            "temperature": 0.8,
            "max_tokens": 150,
            "top_p": 0.9
        }

        # Faire l'appel √† Groq
        response = requests.post(GROQ_API_URL, headers=headers, json=data, timeout=15)

        if response.status_code == 401:
            return "Ma connexion a des soucis ! üòÖ R√©essaie dans un moment !"
        elif response.status_code == 429:
            return "Je suis d√©bord√©e l√† ! üòµ Attends un peu !"
        elif response.status_code != 200:
            return "Oups, j'ai un petit bug ! üôà Tu peux r√©p√©ter ?"

        result = response.json()
        ai_response = result["choices"][0]["message"]["content"].strip()

        # Sauvegarder dans l'historique
        if "conversation_history" not in context:
            context["conversation_history"] = []

        context["conversation_history"].append({
            "user": message,
            "alicia": ai_response
        })

        # Garder seulement les 8 derniers √©changes
        if len(context["conversation_history"]) > 8:
            context["conversation_history"] = context["conversation_history"][-8:]

        return ai_response

    except Exception as e:
        return "J'ai la t√™te ailleurs ! üòÖ Tu disais quoi ?"

def suggest_fanvue_empathically(user_id: int, context: dict) -> str:
    """Sugg√®re Fanvue de mani√®re empathique"""
    suggestions = [
        "Tu sais, je partage beaucoup de contenu exclusif sur mon Fanvue. √áa pourrait t'int√©resser ! üòä https://www.fanvue.com/aliciia/fv-1",
        "Si tu veux en savoir plus sur moi, mon Fanvue est l'endroit id√©al ! üòâ https://www.fanvue.com/aliciia/fv-1",
        "Je poste souvent des mises √† jour sur mon Fanvue. N'h√©site pas √† y jeter un ≈ìil ! üëÄ https://www.fanvue.com/aliciia/fv-1"
    ]
    return random.choice(suggestions)

async def get_alicia_response(message: str, user_id: int) -> str:
    """Fonction principale pour obtenir la r√©ponse d'Alicia"""

    # Initialiser le contexte utilisateur
    if user_id not in user_contexts:
        user_contexts[user_id] = {
            "first_interaction": True,
            "conversation_history": [],
            "user_name": None,
            "start_time": time.time()
        }

    context = user_contexts[user_id]

    # Premi√®re interaction
    if context["first_interaction"]:
        context["first_interaction"] = False
        return "√ßa me fait plaisir de te voir !"

    # V√©rifier si la conversation doit se terminer
    if should_end_conversation(context):
        # R√©initialiser le contexte pour permettre une nouvelle conversation plus tard
        user_contexts[user_id] = {
            "first_interaction": True,
            "conversation_history": [],
            "user_name": None,
            "start_time": time.time()
        }
        return get_ending_message()

    # D√©tecter contenu sexuel - r√©ponse directe
    sexual_score = detect_sexual_content(message)
    if sexual_score > 0:
        increment_sexual_counter(context)
        if should_send_fanvue(user_id, context):
            return random.choice([
                "Haha tu es coquin ! üòè J'ai un Fanvue si √ßa t'int√©resse... https://www.fanvue.com/aliciia/fv-1",
                "Oh l√† l√† ! üòâ Rejoins-moi sur mon Fanvue pour plus ! https://www.fanvue.com/aliciia/fv-1",
                "Tu me fais rougir ! üî• Mon Fanvue : https://www.fanvue.com/aliciia/fv-1"
            ])
        else:
            if sexual_score == 1:
                return random.choice([
                    "Haha tu es coquin ! üòè",
                    "Oh l√† l√† ! üòâ",
                    "Tu me fais rougir ! üî•"
                ])
            elif sexual_score == 2:
                return random.choice([
                    "Waouh, tu n'y vas pas de main morte ! üòè",
                    "Oh l√† l√†, tu me surprends ! üòâ",
                    "Tu me fais vraiment rougir ! üî•"
                ])
            elif sexual_score >= 3:
                return random.choice([
                    "Oh mon dieu, tu es vraiment direct ! üòè",
                    "Waouh, tu es plein d'audace ! üòâ",
                    "Tu me fais carr√©ment rougir ! üî•"
                ])

    # Mentionner qu'elle va bient√¥t partir (avec une petite probabilit√©)
    if should_hint_ending(context) and random.random() < 0.15:  # 15% de chance
        return get_hint_message()

    # Sugg√©rer Fanvue de mani√®re empathique apr√®s quelques interactions
    if len(context["conversation_history"]) > 5 and random.random() < 0.08:  # 8% de chance
        return suggest_fanvue_empathically(user_id, context)

    # Utiliser Groq pour toutes les autres r√©ponses
    return get_groq_response(message, user_id, context)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_contexts[user_id] = {
        "first_interaction": True,
        "conversation_history": [],
        "user_name": None,
        "start_time": time.time()
    }

    await asyncio.sleep(1.5)

    await update.message.reply_text("Coucou toi <3")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await asyncio.sleep(1)

    await update.message.reply_text(
        "**Commandes :**\n"
        "‚Ä¢ /start - On fait connaissance !\n"
        "‚Ä¢ /blague - Une petite blague !\n"
        "‚Ä¢ /clear - On repart √† z√©ro !\n"
        "‚Ä¢ /stats - Statistiques du bot\n\n"
        "**Surtout parle-moi ! üíï**\n"
        "Je suis l√† pour t'√©couter ! üòä"
    )

async def blague_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await asyncio.sleep(1)

    # Utiliser Groq m√™me pour les blagues
    user_id = update.effective_user.id
    blague_request = "Raconte-moi une blague courte et dr√¥le avec ton humour marseillais"
    response = get_groq_response(blague_request, user_id, user_contexts.get(user_id, {}))

    await update.message.reply_text(response)

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Statistiques simples"""
    total_users = len(user_contexts)
    total_conversations = sum(len(ctx.get("conversation_history", [])) for ctx in user_contexts.values())

    await update.message.reply_text(
        f"üìä **Stats Alicia**\n"
        f"üë• Utilisateurs : {total_users}\n"
        f"üí¨ Conversations : {total_conversations}\n"
        f"ü§ñ Mod√®le : Groq Llama 3.1 8B\n"
        f"üî• 100% IA activ√©e !"
    )

async def clear_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_contexts[user_id] = {
        "first_interaction": False,
        "conversation_history": [],
        "user_name": None,
        "start_time": time.time()
    }

    await asyncio.sleep(1)

    await update.message.reply_text("On efface tout ! üîÑ")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_message = update.message.text

    # Calculer un d√©lai r√©aliste avant de traiter (1-2 secondes pour "r√©fl√©chir")
    thinking_delay = random.uniform(1, 2)
    await asyncio.sleep(thinking_delay)

    # G√©n√©rer la r√©ponse d'Alicia via Groq
    response = await get_alicia_response(user_message, user_id)

    # Calculer un d√©lai suppl√©mentaire pour "taper" selon la taille
    typing_delay = calculate_response_delay(response)
    await asyncio.sleep(typing_delay)

    # Envoyer la r√©ponse
    await update.message.reply_text(response)

def main():
    # V√©rifier les tokens
    telegram_token = os.getenv('TELEGRAM_BOT_TOKEN')
    groq_token = os.getenv('GROQ_API_KEY')

    if not telegram_token:
        print("‚ùå Token Telegram manquant dans le fichier .env !")
        return

    if not groq_token:
        print("‚ùå Token Groq manquant dans le fichier .env !")
        print("üìù Va sur https://console.groq.com pour cr√©er ta cl√© API")
        return

    print("üåü D√©marrage d'Alicia - 100% Groq AI avec fin naturelle")
    print("üöÄ Mod√®le : Llama 3.1 8B Instant")

    if groq_token.startswith('gsk_'):
        print(f"‚úÖ Cl√© Groq d√©tect√©e: {groq_token[:15]}...")
        print("üî• Mode IA int√©grale activ√©")
        print("‚è∞ Conversations limit√©es naturellement")
    else:
        print("‚ö†Ô∏è Cl√© Groq invalide (ne commence pas par gsk_)")
        return

    app = Application.builder().token(telegram_token).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("blague", blague_command))
    app.add_handler(CommandHandler("stats", stats_command))
    app.add_handler(CommandHandler("clear", clear_command))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("üíï Alicia est pr√™te !")
    
    app.run_polling()

if __name__ == '__main__':
    main()